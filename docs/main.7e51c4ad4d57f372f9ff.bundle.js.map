{"version":3,"file":"main.7e51c4ad4d57f372f9ff.bundle.js","sources":["webpack:///./projects/eediom-sdk/src/lib/components/overlay/dropdown/color-picker/color-picker.ts"],"sourcesContent":["import { isTrue } from '../../../../common';\n\nexport enum SliderTypes {\n\tHue,\n\tSaturation,\n}\n\nexport enum ColorTypes {\n\tHex = 'hex',\n\tRgb = 'rgb',\n}\n\nexport const transparent = 'transparent';\n\nexport interface Slider {\n\tx: number;\n\ty: number;\n\twidth?: number;\n\theight?: number;\n}\n\nexport const SLIDER_MAX: number = 144;\n\nexport class Rgb {\n\tr: number;\n\tg: number;\n\tb: number;\n\n\tconstructor(r: number, g: number, b: number) {\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\t}\n\n\ttoString() {\n\t\treturn `rgb(${this.r}, ${this.g}, ${this.b})`;\n\t}\n\n\ttoRgb() {\n\t\treturn new Rgb(Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255));\n\t}\n\n\tvalid(): boolean {\n\t\tif (this.r > 255 || this.g > 255 || this.b > 255) return false;\n\n\t\treturn true;\n\t}\n\n\tpublic static parse(value: string): Rgb {\n\t\tconst target = value.replace(/[^0-9|/,]/g, '').split(',');\n\t\tconst rgb = new Rgb(+target[0], +target[1], +target[2]);\n\n\t\tif (!rgb.valid()) throw new Error('value is not rgb type, value: ' + value);\n\n\t\treturn rgb;\n\t}\n}\n\nexport class Rgba {\n\tr: number;\n\tg: number;\n\tb: number;\n\ta?: number;\n\n\tconstructor(r: number, g: number, b: number, a?: number) {\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\t\tthis.a = a;\n\t}\n\n\ttoString() {\n\t\tif (this.a === 1) {\n\t\t\treturn `rgb(${this.r}, ${this.g}, ${this.b})`;\n\t\t}\n\t\treturn `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a})`;\n\t}\n\n\ttoRgba() {\n\t\treturn new Rgba(Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255), this.a);\n\t}\n\n\tvalid() {\n\t\tconst testTarget = [this.r, this.g, this.b, this.a].filter((target) => !isTrue(target) || !isNaN(+target));\n\n\t\tif (testTarget.length !== 4) return false;\n\n\t\tif (this.r > 255 || this.g > 255 || this.b > 255 || this.a > 1) return false;\n\n\t\treturn true;\n\t}\n\n\tpublic static parse(value: string): Rgba {\n\t\tconst target = value.replace(/[^0-9|/,|/.]/g, '').split(',');\n\t\tconst rgba: Rgba = new Rgba(\n\t\t\tparseInt(target[0]),\n\t\t\tparseInt(target[1]),\n\t\t\tparseInt(target[2]),\n\t\t\ttarget[3] !== undefined ? +parseFloat(target[3]).toFixed(2) : 1,\n\t\t);\n\n\t\tif (!rgba.valid()) throw new TypeError('value is not rgba type, value: ' + value);\n\n\t\treturn rgba;\n\t}\n}\n\nexport class Hsv {\n\th: number;\n\ts: number;\n\tv: number;\n\n\tconstructor(h: number, s: number, v: number) {\n\t\tthis.h = h;\n\t\tthis.s = s;\n\t\tthis.v = v;\n\t}\n\n\ttoString() {\n\t\treturn `hsv(${this.h}, ${this.s}%, ${this.v}%)`;\n\t}\n\n\ttoHsv() {\n\t\treturn new Hsv(Math.round(this.h * 360), Math.round(this.s * 100), Math.round(this.v * 100));\n\t}\n}\n\nexport const rgbToHsv = (rgb: Rgb): Hsv => {\n\tlet { r, g, b } = rgb;\n\t(r /= 255), (g /= 255), (b /= 255);\n\n\tconst max = Math.max(r, g, b);\n\tconst min = Math.min(r, g, b);\n\tlet h: number;\n\tlet s: number;\n\tlet v: number = max;\n\n\tconst d = max - min;\n\ts = max === 0 ? 0 : d / max;\n\n\tif (max === min) {\n\t\th = 0; // achromatic\n\t} else {\n\t\tswitch (max) {\n\t\t\tcase r:\n\t\t\t\th = (g - b) / d + (g < b ? 6 : 0);\n\t\t\t\tbreak;\n\t\t\tcase g:\n\t\t\t\th = (b - r) / d + 2;\n\t\t\t\tbreak;\n\t\t\tcase b:\n\t\t\t\th = (r - g) / d + 4;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\th /= 6;\n\t}\n\n\treturn new Hsv(h, s, v).toHsv();\n};\n\nexport const SHORTHAND_HEX_FORMAT = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\nexport const NORMAL_HEX_FORMAT = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\nexport const HEX_FORMAT = /^#(?:[0-9a-fA-F]{3}){1,2}$/i;\nexport const HEXA_FORMAT = /^#(?:[0-9a-fA-F]{3,4}){1,2}$/i;\n\nexport const rgbToHex = (rgb: Rgb): string => {\n\tconst { r, g, b } = rgb;\n\treturn '#' + ((1 << 24) | (r << 16) | (g << 8) | b).toString(16).substr(1);\n};\n\nexport const rgbaToHex = (rgba: Rgba): string => {\n\tconst { r, g, b, a } = rgba;\n\tconst rgb = new Rgb(r, g, b);\n\tconst hex = rgbToHex(rgb);\n\tif (a === 1) {\n\t\treturn hex;\n\t}\n\n\tlet colorHex = parseInt((a * 255).toFixed()).toString(16);\n\tif (colorHex.length === 1) {\n\t\tcolorHex = `0${colorHex}`;\n\t}\n\treturn hex + colorHex;\n};\n\nexport const hexToRgb = (hex: string) => {\n\t// #000 과 같이 축약으로 사용된 hex를 변경\n\thex = hex.replace(SHORTHAND_HEX_FORMAT, (m, r, g, b) => r + r + g + g + b + b);\n\tconst result: string[] = NORMAL_HEX_FORMAT.exec(hex);\n\treturn result ? new Rgb(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) : null;\n};\n\nexport const hsvToRgb = (hsv: Hsv): Rgb => {\n\tif (!isTrue(hsv)) return null;\n\tlet r: number;\n\tlet g: number;\n\tlet b: number;\n\tlet { h, s, v } = hsv;\n\th /= 360;\n\ts /= 100;\n\tv /= 100;\n\tconst i = Math.floor(h * 6);\n\tconst f = h * 6 - i;\n\tconst p = v * (1 - s);\n\tconst q = v * (1 - f * s);\n\tconst t = v * (1 - (1 - f) * s);\n\n\tswitch (i % 6) {\n\t\tcase 0:\n\t\t\t(r = v), (g = t), (b = p);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t(r = q), (g = v), (b = p);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t(r = p), (g = v), (b = t);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t(r = p), (g = q), (b = v);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t(r = t), (g = p), (b = v);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t(r = v), (g = p), (b = q);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(r = 0), (g = 0), (b = 0);\n\t\t\tbreak;\n\t}\n\n\treturn new Rgb(r, g, b).toRgb();\n};\n\nexport const MARGIN = 5;\n\nexport interface ColorPickerBodyProps {\n\tcolor: string;\n\tenableOutputChange: boolean;\n\toutputColorType: ColorTypes;\n}\n\nexport const valueToHexRgba = (value: string): AlphaHex => {\n\tif (isHex(value)) {\n\t\treturn hexaToAlphaHex(value);\n\t}\n\n\treturn null;\n};\n\nexport const isHex = (value: string): boolean => {\n\tif (value.indexOf('#') !== -1) return true;\n\n\treturn false;\n};\n\nexport const hexaToAlphaHex = (hexa: string): AlphaHex => {\n\tif (hexa.length <= 7) return { alpha: 1, hex: hexa };\n\n\tconst alpha = +(parseInt(hexa.substr(-2, 2), 16) / 255).toFixed(2);\n\tconst hex = hexa.substr(0, 7);\n\n\treturn {\n\t\talpha,\n\t\thex,\n\t};\n};\n\nexport const hexaToRgba = (hexa: string): Rgba => {\n\tif (hexa.length <= 7) {\n\t\tconst toRgb: Rgb = hexToRgb(hexa);\n\t\treturn new Rgba(toRgb.r, toRgb.g, toRgb.b, 1);\n\t}\n\n\tconst { hex, alpha } = hexaToAlphaHex(hexa);\n\tconst toRgba: Rgb = hexToRgb(hex);\n\treturn new Rgba(toRgba.r, toRgba.g, toRgba.b, alpha);\n};\n\nexport const stringToRgba = (value: string): Rgba => {\n\tif (isRgba(value)) {\n\t\treturn Rgba.parse(value);\n\t}\n};\n\nexport const isRgba = (value: string) => {\n\tif (value.indexOf('a') !== -1) return true;\n\n\treturn false;\n};\n\nexport type AlphaHex = {\n\talpha: number;\n\thex: string;\n};\n\nexport const stringToHexRgba = (value: string) => {};\n"],"mappings":"AAAA","sourceRoot":""}